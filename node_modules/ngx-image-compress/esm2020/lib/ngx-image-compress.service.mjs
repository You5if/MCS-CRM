import { Injectable } from '@angular/core';
import { ImageCompress } from './image-compress';
import { DOC_ORIENTATION } from './models/DOC_ORIENTATION';
import * as i0 from "@angular/core";
export class NgxImageCompressService {
    constructor(rendererFactory) {
        this.DOC_ORIENTATION = DOC_ORIENTATION;
        this.render = rendererFactory.createRenderer(null, null);
    }
    /**
     * helper to evaluate the compression rate
     * @param imgString the image in base64 string format
     */
    byteCount(image) {
        return ImageCompress.byteCount(image);
    }
    /**
     * Get the correct Orientation value from image tags
     */
    getOrientation(file) {
        return ImageCompress.getOrientation(file);
    }
    /**
     * return a promise with the new image data and image orientation
     */
    uploadFile() {
        return ImageCompress.uploadFile(this.render, false);
    }
    /**
     * return a promise with an array of image data and image orientation
     */
    uploadMultipleFiles() {
        return ImageCompress.uploadFile(this.render, true);
    }
    /**
     * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method
     *
     *
     | Parameter   | Type   | Description                                                                       |
     | ----------- | ------ | --------------------------------------------------------------------------------- |
     | image       | string | DataUrl (string) representing the image                                           |
     | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |
     | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |
     | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |
     | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |
     | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |
     */
    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {
        return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);
    }
    /**
     * Most simple function to use here.
     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*
     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*
     * Put debugMode to true if you have some trouble to print some help using console.debug
     */
    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false) {
        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render);
    }
}
NgxImageCompressService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.1", ngImport: i0, type: NgxImageCompressService, deps: [{ token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
NgxImageCompressService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.2.1", ngImport: i0, type: NgxImageCompressService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.1", ngImport: i0, type: NgxImageCompressService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.RendererFactory2 }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWltYWdlLWNvbXByZXNzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtaW1hZ2UtY29tcHJlc3Mvc3JjL2xpYi9uZ3gtaW1hZ2UtY29tcHJlc3Muc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUE4QixNQUFNLGVBQWUsQ0FBQztBQUN0RSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDL0MsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLDBCQUEwQixDQUFDOztBQU96RCxNQUFNLE9BQU8sdUJBQXVCO0lBTWxDLFlBQVksZUFBaUM7UUFGdEMsb0JBQWUsR0FBRyxlQUFlLENBQUM7UUFHdkMsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLEtBQWM7UUFDN0IsT0FBTyxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7T0FFRztJQUNJLGNBQWMsQ0FBQyxJQUFVO1FBQzlCLE9BQU8sYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxVQUFVO1FBQ2YsT0FBTyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUE0QixDQUFDO0lBQ2pGLENBQUM7SUFFRDs7T0FFRztJQUNJLG1CQUFtQjtRQUN4QixPQUFPLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQThCLENBQUM7SUFDbEYsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNJLFlBQVksQ0FDakIsS0FBYyxFQUNkLFdBQTRCLEVBQzVCLFFBQWdCLEVBQUUsRUFDbEIsVUFBa0IsRUFBRSxFQUNwQixXQUFtQixDQUFDLEVBQ3BCLFlBQW9CLENBQUM7UUFFckIsT0FBTyxhQUFhLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN0RyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSw0QkFBNEIsQ0FBQyxZQUFvQixDQUFDLEVBQUUsU0FBUyxHQUFHLEtBQUs7UUFDMUUsT0FBTyxhQUFhLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFFLENBQUM7O29IQXZFVSx1QkFBdUI7d0hBQXZCLHVCQUF1QixjQUZ0QixNQUFNOzJGQUVQLHVCQUF1QjtrQkFIbkMsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGFibGUsIFJlbmRlcmVyMiwgUmVuZGVyZXJGYWN0b3J5Mn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0ltYWdlQ29tcHJlc3N9IGZyb20gJy4vaW1hZ2UtY29tcHJlc3MnO1xuaW1wb3J0IHtET0NfT1JJRU5UQVRJT059IGZyb20gJy4vbW9kZWxzL0RPQ19PUklFTlRBVElPTic7XG5pbXBvcnQge1VwbG9hZFJlc3BvbnNlfSBmcm9tICcuL21vZGVscy91cGxvYWQtcmVzcG9uc2UnO1xuaW1wb3J0IHtEYXRhVXJsfSBmcm9tICcuL21vZGVscy9kYXRhLXVybCc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5neEltYWdlQ29tcHJlc3NTZXJ2aWNlIHtcblxuICBwcml2YXRlIHJlYWRvbmx5IHJlbmRlcjogUmVuZGVyZXIyO1xuXG4gIHB1YmxpYyBET0NfT1JJRU5UQVRJT04gPSBET0NfT1JJRU5UQVRJT047XG5cbiAgY29uc3RydWN0b3IocmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyKSB7XG4gICAgdGhpcy5yZW5kZXIgPSByZW5kZXJlckZhY3RvcnkuY3JlYXRlUmVuZGVyZXIobnVsbCwgbnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogaGVscGVyIHRvIGV2YWx1YXRlIHRoZSBjb21wcmVzc2lvbiByYXRlXG4gICAqIEBwYXJhbSBpbWdTdHJpbmcgdGhlIGltYWdlIGluIGJhc2U2NCBzdHJpbmcgZm9ybWF0XG4gICAqL1xuICBwdWJsaWMgYnl0ZUNvdW50KGltYWdlOiBEYXRhVXJsKSB7XG4gICAgcmV0dXJuIEltYWdlQ29tcHJlc3MuYnl0ZUNvdW50KGltYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvcnJlY3QgT3JpZW50YXRpb24gdmFsdWUgZnJvbSBpbWFnZSB0YWdzXG4gICAqL1xuICBwdWJsaWMgZ2V0T3JpZW50YXRpb24oZmlsZTogRmlsZSk6IFByb21pc2U8RE9DX09SSUVOVEFUSU9OPiB7XG4gICAgcmV0dXJuIEltYWdlQ29tcHJlc3MuZ2V0T3JpZW50YXRpb24oZmlsZSk7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIHRoZSBuZXcgaW1hZ2UgZGF0YSBhbmQgaW1hZ2Ugb3JpZW50YXRpb25cbiAgICovXG4gIHB1YmxpYyB1cGxvYWRGaWxlKCk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCBmYWxzZSkgYXMgUHJvbWlzZTxVcGxvYWRSZXNwb25zZT47XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIGFuIGFycmF5IG9mIGltYWdlIGRhdGEgYW5kIGltYWdlIG9yaWVudGF0aW9uXG4gICAqL1xuICBwdWJsaWMgdXBsb2FkTXVsdGlwbGVGaWxlcygpOiBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+IHtcbiAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCB0cnVlKSBhcyBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+O1xuICB9XG5cbiAgLyoqXG4gICAqIHBlcmZvcm0gYSBjb21wcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBEYXRhVXJsIChzdHJpbmcpLCBwcm92aWRlZCBieSB0aGUgdXBsb2FkRmlsZSwgb3IgdXBsb2FkTXVsdGlwbGVGaWxlcyBtZXRob2RcbiAgICpcbiAgICpcbiAgIHwgUGFyYW1ldGVyICAgfCBUeXBlICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgfCAtLS0tLS0tLS0tLSB8IC0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gICB8IGltYWdlICAgICAgIHwgc3RyaW5nIHwgRGF0YVVybCAoc3RyaW5nKSByZXByZXNlbnRpbmcgdGhlIGltYWdlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgIHwgb3JpZW50YXRpb24gfCBudW1iZXIgfCBFWElGIE9yaWVudGF0aW9uIHZhbHVlIHVzaW5nIHRoZSBET0NfT1JJRU5UQVRJT04gZW51bSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgfCByYXRpbyAgICAgICB8IG51bWJlciB8IE1heGltdW0gc2NhbGUgZmFjdG9yIGFzIGEgcGVyY2VudGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDUwKSA8c3VwPlsxXSgjZm4xKTwvc3VwPiB8XG4gICB8IHF1YWxpdHkgICAgIHwgbnVtYmVyIHwgSlBFRyBxdWFsaXR5IGZhY3RvciBhcyBhIHBlcmNlbnRhZ2UgKG9wdGlvbmFsLCBkZWZhdWx0OiA1MCkgPHN1cD5bMl0oI2ZuMik8L3N1cD4gIHxcbiAgIHwgbWF4d2lkdGggICAgfCBudW1iZXIgfCBNYXhpbXVtIHdpZHRoIGluIHBpeGVscyBpZiB5b3UgbmVlZCB0byByZXNpemUgKG9wdGlvbmFsLCBkZWZhdWx0OiAwIC0gbm8gcmVzaXplKSAgfFxuICAgfCBtYXhoZWlnaHQgICB8IG51bWJlciB8IE1heGltdW0gaGVpZ2h0IGluIHBpeGVscyBpZiB5b3UgbmVlZCB0byByZXNpemUgKG9wdGlvbmFsLCBkZWZhdWx0OiAwIC0gbm8gcmVzaXplKSB8XG4gICAqL1xuICBwdWJsaWMgY29tcHJlc3NGaWxlKFxuICAgIGltYWdlOiBEYXRhVXJsLFxuICAgIG9yaWVudGF0aW9uOiBET0NfT1JJRU5UQVRJT04sXG4gICAgcmF0aW86IG51bWJlciA9IDUwLFxuICAgIHF1YWxpdHk6IG51bWJlciA9IDUwLFxuICAgIG1heFdpZHRoOiBudW1iZXIgPSAwLFxuICAgIG1heEhlaWdodDogbnVtYmVyID0gMFxuICApOiBQcm9taXNlPERhdGFVcmw+IHtcbiAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy5jb21wcmVzcyhpbWFnZSwgb3JpZW50YXRpb24sIHRoaXMucmVuZGVyLCByYXRpbywgcXVhbGl0eSwgbWF4V2lkdGgsIG1heEhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogTW9zdCBzaW1wbGUgZnVuY3Rpb24gdG8gdXNlIGhlcmUuXG4gICAqIFBlcmZvcm0gYW4gdXBsb2FkIGFuZCByZXR1cm4gYW4gaW1hZ2UgZGF0YVVybCAoc3RyaW5nIGZvcm1hdCkgd2l0aCBhIG1heGltdW0gc2l6ZSwgZ2l2ZW4gaW4gKk1lZ2FCeXRlcypcbiAgICogSWYgdGhlIHNpemUgY2FuJ3QgYmUgcmVhY2hlZCwgdGhlIGJlc3QgdGhhdCBjYW4gYmUgcmVhY2hlZCB3aWxsIGJlIHJldHVybmVkIGluIHByb21pc2UgKnJlamVjdGlvbipcbiAgICogUHV0IGRlYnVnTW9kZSB0byB0cnVlIGlmIHlvdSBoYXZlIHNvbWUgdHJvdWJsZSB0byBwcmludCBzb21lIGhlbHAgdXNpbmcgY29uc29sZS5kZWJ1Z1xuICAgKi9cbiAgcHVibGljIHVwbG9hZEFuZEdldEltYWdlV2l0aE1heFNpemUobWF4U2l6ZU1iOiBudW1iZXIgPSAxLCBkZWJ1Z01vZGUgPSBmYWxzZSk6IFByb21pc2U8RGF0YVVybD4ge1xuICAgIHJldHVybiBJbWFnZUNvbXByZXNzLmdldEltYWdlTWF4U2l6ZShtYXhTaXplTWIsIGRlYnVnTW9kZSwgdGhpcy5yZW5kZXIpO1xuICB9XG59XG4iXX0=